# MySQL - 事务








<extoc></extoc>

## 介绍

事务就是满足 `ACID` 特性的一组操作 

在 `MySQL` 中 , 可以用 `START TRANSACTION` 或 `BEGIN` 开启一个事务 , 然后使用 `COMMIT` 提交事务将修改的数据持久保留 , 或者使用 `ROLLBACK` 撤销所有的修改

在 `MySQL` 中默认自动提交 (Autocommit) , 如果需要通过明确的 `COMMIT` 和 `ROLLBACK` 来提交和回滚事务 , 那么就需要通过明确的事务控制命令来开始事务 


## ACID

### 原子性 (Atomicity)

一个事务必须被视为一个不可分割的最小工作单元 , 整个事务中的所有操作要么全部提交成功 , 要么全部失败回滚 , 对于一个事务来说 , 不可能只执行其中的一部分操作

### 一致性 (Consistency)

数据库在事务执行前后都保持一致性状态 , 在一致性状态下 , 所有事务对同一个数据的读取结果都是相同的

### 隔离性 (Isolation)

一个事务所做的修改在最终提交以前 , 对其他事务是不可见的

### 持久性 (Durability)

一旦事务提交 , 则其所做的修改就会永久保存到数据库中 , 此时即使系统崩溃 , 修改的数据也不会丢失

## 并发问题

在没有并发的情况下 , 事务串行执行 , 隔离性一定能够满足 , 但是在并发的情况下 , 多个事务并行执行 , 事务的隔离性就无法得到保证

### 丢失修改

丢失修改是指一个事务的更新操作被另外一个事务的更新操作覆盖

**例如 :** `T1` 和 `T2` 两事务同时获取了一个数据 , `T1` 先修改并提交生效 , 随后 `T2` 又修改并提交 , 这个时候 `T1` 的修改就会被 `T2` 覆盖掉

### 读脏数据

读脏数据是指在不同的事务下 , 一个事务可以读到另一个事务未提交的数据

**例如 :** `T1` 和 `T2` 两个事务 , `T1` 先修改某个数据并提交生效 , 随后 `T2` 获取该数据 , 但是这个时候 `T1` 由于某些原因把刚才的修改撤销了 , 也就是回滚了 , 这个时候 `T2` 获取的数据就是脏数据

### 不可重复读

不可重复读是指一个事务中多次读取同一个数据 , 由于中途被其他事务修改了 , 导致读取的结果不一致

**例如 :** `T1` 和 `T2` 两个事务 , `T1` 先读取了一个数据 , 这时 `T2` 将这个数据进行修改 , 之后 `T1` 又读取这个数据 , 发现两次读取操作获取的结果不一致 , 注意 `T1` 的两次读取是一组操作

### 幻影读

幻影读本质上也属于不可重复读 , 它也是一个事务中多次读取数据 , 但是由于中途被其他事务新增或者删除了 , 导致读取的条数不一致

**例如 :** `T1` 和 `T2` 两个事务 , `T1` 读取某个范围的数据 , `T2` 在这个范围内新增或者删除了某条数据 , 这个时候  `T1` 再次读取这个范围的数据 , 这个时候读取的结果和第一次读取的结果不一致

产生并发不一致问题的主要原因是破坏了事务之间的隔离性 , 要解决这个问题就是要通过并发控制来保证隔离性 , 使一个事务的执行不受其他事务的干扰 , 从而避免造成过数据的不一致性 , 而实现并发控制的一个非常重要的技术就是封锁

## 封锁

### 封锁粒度

在 `MySQL` 中 , 不同的存储引擎 , 提供的封锁粒度是不一样的 , 各个存储引擎对封锁粒度的支持如下 : 

| 存储引擎 | MyISAM | InnoDB | MEMORY | MERGE  | NDB    |
| -------- | ------ | ------ | ------ | ------ | ------ |
| 封锁粒度 | 表级锁 | 行级锁 | 表级锁 | 表级锁 | 行级锁 |

除了表级锁和行级锁之外 , 在早期 `MySQL 5.1` 之前 , 还有 `BDB` 存储引擎 , 支持页面锁 , 这三种锁的特性如下 : 

- 表级锁 : 开销小 , 加锁快 ; 不会出现死锁 ; 锁定粒度大 , 发生锁冲突的概率最高 , 并发度最低
- 行级锁 : 开销大 , 加锁慢 ; 会出现死锁 ; 锁定粒度最小 , 发生锁冲突的概率最低 , 并发度也最高
- 页面锁 : 开销和加锁时间介于表锁和行锁之间 ; 会出现死锁 ; 锁定粒度介于表锁和行锁之间 , 并发度一般

从上述特点可见 , 很难笼统地说哪种锁更好 , 在选择封锁粒度时 , 需要在开销和并发度之间做一个权衡

### 封锁类型

基本封锁类型有两种 , 共享锁 (Shared) , 简写为 S 锁 , 又称读锁 ;  排他锁 (Exclusive) 也可以叫互斥锁 , 简写为 X 锁 , 又称写锁

**共享锁 :** 一个事务对数据对象 A 加了 S 锁 , 可以对 A 进行读取操作 , 但是不能进行更新操作 , 加锁期间其它事务能对 A 加 S 锁 , 但是不能加 X 锁

**排他锁 :** 一个事务对数据对象 A 加了 X 锁 , 就可以对 A 进行读取和更新操作 , 加锁期间其它事务不能对 A 加任何锁

除了共享锁和排他锁之外 , 为了允许行锁和表锁共存 , 实现多粒度锁机制 , 还有意向锁 (Intention Locks)

意向共享锁 (IS) : 一个事务在获取某个数据行对象的 S 锁之前 , 必须 先获得表的 IS 锁或者更强的锁

意向排他锁 (IX) : 一个事务在获取某个数据行对象的 X 锁之前 , 必须先获得表的 IX 锁

意向锁兼容关系如下 : 

| 锁   | X    | IX       | S        | IS       |
| ---- | ---- | -------- | -------- | -------- |
| X    | 冲突 | 冲突     | 冲突     | 冲突     |
| IX   | 冲突 | **兼容** | 冲突     | **兼容** |
| S    | 冲突 | 冲突     | **兼容** | **兼容** |
| IS   | 冲突 | **兼容** | **兼容** | **兼容** |

解释如下 : 

1. 任意 IS/IX 锁之间都是兼容的 , 因为它们只表示想要对表加锁 , 而不是真正加锁
2. 这里的兼容关系针对的表级锁 , 而表锁的 IX 锁和行级的 X 锁兼容 ,  两个事务可以对两个数据行加 X 锁

### 封锁协议

在运用锁对数据对象加锁时 , 还需要约定一些规则 , 例如应何时申请X锁或S锁 , 持锁时间 , 何时释放等 , 这就是封锁协议 (Locking Protocol)

**一级封锁协议**

事务 T 在修改数据 A 之前必须先对其加 X 锁 , 直到事务结束才释放

一级封锁协议可防止丢失修改 , 因为不能同时有两个事务对同一个数据进行修改 , 所以事务的修改不会被覆盖

**二级封锁协议**

在一级封锁协议的基础上 , 要求读取数据 A 之前必须先对其加 S 锁 , 读完后即可释放 S 锁

二级封锁协议除了防止丢失修改 , 还可以防止读脏数据 , 因为根据一级封锁协议 , 在修改数据时 , 会加 X 锁 , 这样就无法再加 S 锁了 , 也就不会再次读取数据

**三级封锁协议**

在一级封锁协议的基础上 , 要求读取数据 A 之前必须对其加 S 锁 , 直到事务结束才能释放 S 锁

三级封锁协议除了防止丢失修改和读脏数据之外 , 还进一步防止了不可重复读

**两阶段锁定协议**

加锁和解锁分为两个阶段进行 , 在事务执行过程追踪 , 随时都可以执行锁定 , 锁只有在执行 `COMMIT` 或者 `ROLLBACK` 的时候才会释放 , 并且所有的锁是在同一时刻释放 , InnoDB 采用的正式这种协议

**隐式和显式锁定**

`InnoDB` 会根据隔离级别在需要的时候自动加锁 (隐式) , 同时也支持通过特定的语句进行显式锁定 

```SQL
SELECT ... LOCK IN SHARE MODE;
SELECT .. FOR UPDATE;
```

## 隔离级别

并发控制可以通过封锁来实现 , 但是封锁需要用户自己控制如何加锁 , 以及加锁和解锁的时机 , 相当复杂 , 所以绝大多数数据库以及开发工具都提供了事务的隔离级别 , 让用户以一种更轻松的方式处理并发一致性问题

### 未提交读 (READ UNCOMMITTED)

事务中的修改，即使没有提交，对其它事务也是可见的 , 也就意味着会出现脏读现象

这个级别会导致很多问题 , 从性能上来说 , `READ UNCOMMITTED` 不会比其他的级别好太多 , 但却缺乏其他级别的很多好处 , 除非真的有非常必要的理由 , 在实际应用中一般很少使用

### 提交读 (READ COMMITTED)

一个事务只能读取已经提交的事务所做的修改 , 换句话说 , 一个事务从开始直到提交之前 , 所做的任何修改对其他事务都是不可见的

大多数数据库系统的默认隔离级别都是 `READ COMMITTED` 

### 可重复读 (REPEATABLE READ)

保证在同一个事务中多次读取同一数据的结果是一致的

但是理论上 , 可重复读隔离级别还是无法解决幻读问题 , 可重复读是 `MySQL` 的默认事务隔离级别

### 可串行化 (SERIALIZABLE)

强制事务串行执行 , 这样多个事务互不干扰，不会出现并发一致性问题

该隔离级别需要加锁实现 , 因为要使用加锁机制保证同一时间只有一个事务执行 , 也就是保证事务串行执行

`SERIALIZABLE` 会在读取的每一行数据上都加锁 , 所以可能导致大量的超时和锁争用的问题 , 实际应用中很少用到这个隔离级别 , 只有在非常需要确保数据的一致性而且可以接受没有并发的情况下 , 才考虑采用该级别

这四个隔离级别对比如下 : 

| 隔离级别 | 读数据一致性                              | 脏读 | 不可重复读 | 幻影读 |
| -------- | ----------------------------------------- | ---- | ---------- | ------ |
| 未提交读 | 最低级别 , 只能保证不读取物理上损坏的数据 | 是   | 是         | 是     |
| 已提交读 | 语句级                                    | 否   | 是         | 是     |
| 可重复读 | 事务级                                    | 否   | 否         | 是     |
| 可序列化 | 最高级别 , 事务级                         | 否   | 否         | 否     |


## MySQL中使用事务

语法 : 

```mysql
START TRANSACTION|BEGIN[WORK]

COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]

ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]

SET AUTOCOMMIT = {0/1}

-- START TRANSACTION 或 BEGIN 语句可以开始一项新的事务
-- COMMIT 和 ROLLBACK 用来提交或者回滚事务
-- CHAIN 和 RELEASE子句分别用来定义在事务提交或者回滚之后的操作,CHAIN会立即启动一个新事务,宾且和刚才的事务具有相同的隔离级别,RELEASE则会断开和客户端的连接
-- SET AUTOCOMMIT可以修改当前连接的提交方式,如果设置了 SET AUTOCOMMIT=0,则设置之后的所有事务都需要通过明确的命令进行提交或者回滚
```

实例

```mysql
mysql> DELIMITER $$
mysql> CREATE PROCEDURE p1(
    -> OUT p_return_code TINYINT
    -> )
    -> BEGIN
    -> 	 DECLARE EXIT HANDLER FOR SQLEXCEPTION
    -> 	 BEGIN  -- ERROR
    ->     SET p_return_code = 1;
    ->     ROLLBACK;  -- 回滚
    ->   END;
    ->   DECLARE EXIT HANDLER FOR SQLWARNING
    ->   BEGIN  -- WARNING
    ->     SET p_return_code = 2;
    ->     ROLLBACK;  
    ->   END;
    ->   START TRANSACTION;  -- 开始事务
    ->     DELETE FROM tb1;
    ->     INSERT INTO tb2(name) values('lyon');
    ->   COMMIT;
    ->   SET p_return_code = 0;  -- SUCCESS
    -> END $$
Query OK, 0 rows affected (0.10 sec)
-- 调用
SET @i = 0;
CALL p1(@i);
SELECT @i;
```