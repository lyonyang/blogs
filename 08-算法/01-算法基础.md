# 算法基础


<extoc></extoc>

## 介绍  🍀

**定义**

> 算法是解决特定问题求解步骤的描述 , 在计算机中表现为指令的有限序列 , 并且每条指令表示一个或多个操作

**算法的特性**

1. **输入输出**

   算法具有零个或多个输入 , 算法至少有一个或多个输出

2. **有穷性**

   算法在执行有限的步骤之后 , 自动结束而不会出现无限循环 , 并且每一个步骤在可接受的时间内完成

3. **确定性**

   算法的每一步骤都具有确定的含义

4. **可行性**

   算法的每一步都必须是可行的 , 也就是说 , 每一步都能够通过执行有限次数完成

## 设计要求  🍀

解决一个问题的途径可以有非常多种 , 掌握好的算法 , 对我们解决问题很有帮助 , 而一个好的算法应该具备以下要求

**正确性**

算法的正确性是指算法至少应该具有输入 , 输出和加工处理无歧义性 , 能正确反应问题的需求 , 能够得到问题的正确答案

正确性应该符合以下四点 : 

1. 算法程序没有语法错误
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果
4. 算法程序对于精心选择的 , 甚至刁难的测试数据都有满足要求的输出结果

**健壮性**

一个好的算法还应该能对输入数据不合法的情况做合适的处理 , 比如输入的时间或者距离不应该是负数等

健壮性就是当输入数据不合法时 , 算法也能作出相关处理 , 而不是产生异常或者莫名奇妙的结果

**时间效率高和存储量低**

时间效率是指算法的执行时间 , 对于同一个问题 , 如果有多个算法能够解决 , 执行时间短的算法效率高 , 执行时间长的效率低 

存储量需求值的是在执行过程中需要的最大存储空间 , 主要指算法程序运行时所占用的内存或外部硬盘空间

**设计算法应该尽量满足时间效率和存储量低的要求**

## 效率的度量方法  🍀

**事后统计方法**

这种方法主要是通过设计好的测试程序和数据 , 利用计算机计时器对不同算法编程的程序的运行时间进行比较 , 从而确定算法效率的高低

但是这种方法是有很大的缺陷的 : 

- 必须依据算法事先编制好程序 , 这通常需要花费大量的时间和精力 , 并且一旦编制出来发现它根本是很糟糕的算法 , 那就白忙活了
- 时间的比较依赖计算机硬件和软件等环境因素 , 有时会掩盖算法本身的优劣
- 算法的测试数据设计困难 , 并且程序的运行时间往往还与测试数据的规模有很大的关系 , 效率高的算法在小的测试数据面前往往得不到体现 ; 比如10个数据的排序 , 不管用什么算法 , 差异几乎是零 , 而如果有一百万个随机数据排序 , 那不同的算法的差异就非常大了 , 所以用多少数据来测试我们的算法 , 这是一个很难判断的问题

**事前分析估算方法**

事前分析估算方法就是在计算机程序编制前 , 依据统计方法对算法进行估算

一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素 : 

1. 算法采用的策略 , 方法
2. 编译产生的代码质量
3. 问题的输入规模
4. 机器执行指令的速度

抛开与计算机硬件 , 软件有关的因素 , 一个程序的运行时间 , 依赖于算法的好坏和问题的输入规模

## 时间复杂度  🍀

在进行算法分析时 , 语句总的执行次数`T(n)`是关于问题规模`n`的函数 , 进而分析`T(n)`随`n`的变化情况并确定`T(n)`的数量级

算法的时间复杂度 , 也就是算法的时间量度 , 记作 : `T(n)=O(f(n))` ; 它表示岁问题规模`n` 的增大 , 算法执行时间的增长率和`f(n)`的增长率相同 , 称作算法的渐进时间复杂度 , 简称为时间复杂度 , 其中`f(n)`是问题规模n的某个函数

我们用大写`O()` 来体现算法时间复杂度的记法 , 称之为`大O记法`

### 推导大O阶  🍀

分析一个算法的时间复杂度 , 推导大O阶时有以下方法 : 

1. 用常数1取代运行时间的所有加法常数
2. 在修改后的运行次数函数中 , 只保留最高阶项
3. 如果最高阶项存在且不是1 , 则去除与这个项相乘的常数

由此得到的结果就是大O阶

### 常数阶  🍀

首先介绍顺序结构的时间复杂度 , 现有如下算法

```python
n = 100				# 执行一次
sum = (1+n)*n/2		# 执行一次
print(sum)          # 执行一次
```

这个算法的运行次数函数是`f(n)=3` , 根据推导大O阶的方法 , 直接把常数项改为1 , 在保留高阶项时发现 , 它根本没有最高阶项 , 所以这个算法的时间复杂度为`O(1)`

注意 : 不管这个常数是多少 , 我们都记作`O(1)` , 而不是`O(3)`等其他任意数字

对于分支结构而言 , 无论是真还是假 , 执行的次数都是恒定的 , 不会随着n的变大而发生变化 , 所以单纯的分支结构 (不包含在循环结构中) , 其时间复杂度也是`O(1)`

### 线性阶  🍀

线性阶的循环结构会复杂很多 , 要确定某个算法的阶次 , 我们常常需要确定某个特定语句或某个语句集运行的次数 ; 因此 , 我们要分析算法的复杂度 , 关键就是要分析循环结构的运行情况 , 如下 : 

```python
for i in range(n):
    print(i)           # 时间复杂度为O(1)
```

上面代码中 , `print`语句会执行`n`次 , 所以它的算法复杂度为`O(n)`

### 对数阶  🍀

```python
count = 1
while count < n:
    count *= 2
```

上面代码中 , 每次`count`乘以2之后 , 就距离`n`更近了一分 , 也就是说 , 有多少个2想乘后大于`n` , 则会退出循环 , 由`2^x = n` 可以得到`x = log2n`  , 所以这个循环的时间复杂度为`O(logn)`

### 平方阶  🍀

下面例子是一个循环嵌套 

```python
for i in range(n):
    for j in range(n):
        print(i,j)     
```

对于外层的循环 , 时间复杂度为`O(n)` , 而内部循环时间复杂度也为`O(n)` , 所以这段代码的时间复杂度为`O(n²)`  , 如果将外层循环改成`m` , 那么时间复杂度就会变成`O(m×n)`

**常见时间复杂度**

| 执行次数函数            | 阶        | 非正式术语  |
| ----------------- | -------- | ------ |
| 12                | O(1)     | 常数阶    |
| 2n+3              | O(n)     | 线性阶    |
| 3n²+2n+1          | O(n²)    | 平方阶    |
| 5log2n + 20       | O(logn)  | 对数阶    |
| 2n + 3nlog2n + 19 | O(nlogn) | nlogn阶 |
| 6n³ + 2n² + 3n +4 | O(n³)    | 立方阶    |
| 2"                | O(2")    | 指数阶    |

常用时间复杂度所耗费的时间从小到大一次是 : 

`O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2") < O(n!) < O(n")`

## 空间复杂度  🍀

算法的空间复杂度通过计算算法所需的存储空间实现 , 算法空间复杂度的计算公式记作 : `S(n) = O(f(n))` , 其中`n`为问题的规模 , `f(n)`为语句关于`n`所占存储空间的函数

一般情况下 , 一个程序在机器上执行时 , 除了需要存储程序本身的指令 , 常数 , 变量和输入数据外 , 还需要存储对数据操作的存储单元 , 若输入数据所占空间值取决于问题本身 , 和算法无关 , 这样只需要分析该算法在实现时所需的辅助单元即可

若算法执行时所需的辅助空间相对于输入数据量而言是个常数 , 则称此算法为原地工作 , 空间复杂度为`O(1)`