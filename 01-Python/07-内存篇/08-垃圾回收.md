#  Attack on Python - 垃圾回收 🐍








<extoc></extoc>

## 介绍

引用计数在对Python内置数据类型的分析时 , 已经见过太多次了 , 就是通过对象中的`ob_refcnt`变量来实现的

在Python中引用计数是一种垃圾收集机制 , 并且是一种最直观 , 最简单的垃圾收集技术

虽然引用计数必须在每次分配和释放内存的时候加入管理引用计数的动作 , 然而与其他主流的垃圾收集技术相比 , 引用计数有一个最大的优点 , 即实时性 , 任何内存 , 一旦没有指向它的引用 , 就会立即被回收 ;  而其他的垃圾收集计数必须在某种特殊条件下 (比如内存分配失败) 才能进行无效内存的回收

引用计数机制所带来的维护引用计数的额外操作与Python运行中所进行的内存分配和释放 , 引用赋值的次数是成正比的 , 这是Python的一个弱点 , 因此在Python内置数据类型中就大量使用了对象缓冲池机制 , 就是为了竭力弥补引用计数机制的软肋

除了执行效率这个软肋之外 , 引用计数还存在一个致命的弱点 , 那就是循环引用

## 循环引用

我们知道 , 当一个对象的引用被创建或复制时 , 对象的引用计数就会加1 ; 而当一个对象的引用被销毁时 , 对象的引用计数就会减1 ; 如果对象的引用计数减少为0 , 那么就以为着这个对象不会被任何人使用 , 那么就可以进行回收了

而引用计数的另一个现象就是循环引用了 , 就相当于有两个对象`a`和`b` , 其中`a`引用了`b` , `b`引用了`a` , 这样`a`和`b`的引用计数都为1 , 并且永远都不会为0 , 这就意味着 , 这两个对象永远都不会被回收了 , 这就是循环引用 , `a`与`b`形成了一个引用循环 , 示例如下 : 

```python
# 我们让list1中包含list2的引用,而list2中又包含list1的引用,形成引用循环
>>> list1 = []
>>> list2 = []
>>> list1.append(list2)
# 此时还没有形成引用循环
>>> list1
[[]]
# 循环引用
>>> list2.append(list1)
>>> l1
[[[...]]]
>>> l2
[[[...]]]
'''
[...]:这就是list循环引用的结果
'''
```

除了上述两个对象互相引用之外 , 还可以引用自身 , 示例如下 : 

```python
>>> list3 = []
>>> list3.append(list3)
>>> list3
[[...]]
```

循环引用与手动进行内存管理所产生的内存泄漏毫无区别 , 不过循环引用对于`int`或者`str`类型明显是不存在的

所以为了解决循环引用的问题 , Python引入了主流垃圾收集技术中的标记——清除和分代收集两种技术来填补其内存管理机制中最致命的漏洞

##  标记清除

垃圾收集机制一般分为两个阶段 : 垃圾检测和垃圾回收

垃圾检测是从所有的已分配的内存中区别出可以回收的内存和不可回收的内存 , 而垃圾回收则是使系统重新掌握在垃圾检测阶段被标识出来的可回收内存块

对于标记——清除方法其简要工作过程如下 : 

- 寻找根对象的集合 , 所谓根对象就是一些全局引用和函数栈中的引用 , 这些引用的对象是不可被删除的, 而这个根对象集合也是垃圾检测动作的起点
- 从根对象的集合 , 沿着根对象集合中的每一个引用 , 如果能到达某个对象A , 则A称为可达的 , 可达的对象也不可被删除 , 这个阶段就是垃圾检测阶段
- 当垃圾检测阶段结束后 , 所有的对象分为了可达的和不可达的两部分 , 所有的可达的对象都必须予以保留 , 而所有的不可达对象所占用的内存将被回收 , 这就是垃圾回收阶段

## 分代回收

我们的开发程序 , 其一定比例的内存块的生存周期都比较短 , 通常是几百万条机器指令的时间 , 而只有剩下的极少部分内存块 , 生存周期比较长 , 而对于不同的语言 , 不同的应用程序 , 生存周期比较短的内存块的比例通常在80%到98%之间游走

从上面我们知道 , 标记——清除技术所带来的额外操作实际上与系统中总的内存块的数量是相关的 , 当需要回收的内存块越多时 , 垃圾检测带来的额外操作就越多 , 而垃圾回收带来的额外操作就越少

所以通常为了提高垃圾收集的效率 , 我们就可以采用一种以空间换时间的策略 , 分代回收计数 , 这也是当前支撑着Java的关键技术

分代回收 : 将系统中的所有内存块根据其存活时间划分为不同的集合 , 每一个集合就称为一个 "代" , 垃圾收集的频率随着 "代" 的存活时间的增大而减小 

也就是说 , 活得越长的对象 , 就越可能不是垃圾 , 就应该越少去收集 . 而这个存活时间通常就是利用经过了几次垃圾收集动作来衡量 ; 如果一个对象经过的垃圾收集次数越多, 那么显然 , 其存活时间就越长

在Python中 , 一个 "代" 就是一个链表 , Python采用了三代的分代收集机制

`Python-2.7\Modules\gcmodule.c`

```C
32:struct gc_generation {
33:    PyGC_Head head;
       /* 回收阀值 */
34:    int threshold; /* collection threshold */ 
       /* 实时个数 */
35:    int count; /* count of allocations or collections of younger
36:                  generations */
37:};

39:#define NUM_GENERATIONS 3
40:#define GEN_HEAD(n) (&generations[n].head)
41:
42:/* linked lists of container objects */
43:static struct gc_generation generations[NUM_GENERATIONS] = {
44:    /* PyGC_Head,                               threshold,      count */
       /* 第0代,可收集700个container对象,一旦超出就立即触发垃圾回收机制 */
45:    {{{GEN_HEAD(0), GEN_HEAD(0), 0}},           700,            0},
46:    {{{GEN_HEAD(1), GEN_HEAD(1), 0}},           10,             0},
47:    {{{GEN_HEAD(2), GEN_HEAD(2), 0}},           10,             0},
48:};
49:
50:PyGC_Head *_PyGC_generation0 = GEN_HEAD(0);
```
