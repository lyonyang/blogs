# Python之路 - 递归

## 递归算法 🍀
递归算法是一种直接或者间接地调用自身算法的过程（递归函数就是一个体现）。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简介而且易于理解。

特点：👈

1. 递归就是再过程或函数里调用自身
2. 再使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。递归算法解题通常显得很简洁，但递归算法解题的运行效率低
3. 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序

要求：👈


1. 每次调用在问题规模上都有所减少（通常是减半）
2. 相邻两次重复之间有紧密的联系，前一次要为后一次做准备（通常前一次的输出就作为后一次的输入）
3. 再问题的规模极小时必须要直接给出解答而不再进行递归调用，因而每次递归调用都是有条件的（以规模未达到直接解答的大小为条件），无条件递归条用将会称为死循环而不能正常结束

## 递归函数 🍀

面向函数编程中，利用递归思想来解决一些简单的问题是非常简单便洁的

递归函数就是函数内部通过调用自己本身来实现功能的函数。既然是调用自身,那么每次调用，需要解决的问题就应该有所减少，不然这个函数就没有尽头的执行下去。

打印10-0

```python
def counter(num):
    # 打印num
    print(num)
    # 如果num小于等于0
    if num <= 0:
        # 返回num
        return num
    # 必须相对上一次有所减少
    num -= 1
    # 反复调用，直到return将函数停止运行
    counter(num)
# 调用函数
counter(10)
```

## 递归应用  🍀

用递归实现斐波那契数列

```python
l = []
def fibonacci(n1,n2):
    # 大于1000后结束递归
    if n1 > 2000:
        # 终止函数，并返回 "不搞了"
        return "不搞了！"
    # 追加进列表
    l.append(n1)
    # 前两个数之和
    n3 = n1 + n2
    # 进行递归
    fibonacci(n2, n3)
# 从0开始
fibonacci(0, 1)
print(l)
```

用递归实现三级菜单

```python
menu = {
    '北京': {
        '海淀': {
            '五道口': {
                'soho': {},
                '网易': {},
                'google': {}
            },
            '中关村': {
                '爱奇艺': {},
                '汽车之家': {},
                'youku': {},
            },
            '上地': {
                '百度': {},
            },
        },
        '昌平': {
            '沙河': {
                '老男孩': {},
                '北航': {},
            },
            '天通苑': {},
            '回龙观': {},
        },
        '朝阳': {},
        '东城': {},
    },
    '上海': {
        '闵行': {
            "人民广场": {
                '炸鸡店': {}
            }
        },
        '闸北': {
            '火车战': {
                '携程': {}
            }
        },
        '浦东': {},
    },
    '山东': {},
}
def threeLM(menu):
    while True:
        # 打印本级菜单内容
        for key in menu:
            # 打印字典的key
            print(key)
        # 用户输入内容
        chooice = input("请输入菜单>>")
        if chooice == 'back':
            return 
        elif chooice == 'quit':
            return 'q'
        if chooice in menu.keys():
            # 将新字典作为参数进行递归调用
            ret = threeLM(menu[chooice])
            if ret == 'q':return 'q'
threeLM(menu)
```





